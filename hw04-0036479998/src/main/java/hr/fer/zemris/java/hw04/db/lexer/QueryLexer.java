package hr.fer.zemris.java.hw04.db.lexer;

/**
 * Lexer which return tokens generated by the inputed string.
 * 
 * @author Lovro MarkoviÄ‡
 *
 */
public class QueryLexer {

	/**
	 * All the characters in the given string.
	 */
	private char[] data;

	/**
	 * Current index of the char that is not yet processed.
	 */
	private int currentIndex;

	/**
	 * Current token that will be returned.
	 */
	private Token token;

	/**
	 * Contructor for the lexer objects. Aceepts the input string as argument.
	 * 
	 * @param query
	 *            input string.
	 * @throws IllegalArgumentException
	 *             Exception thrown when input query is null.
	 */
	public QueryLexer(String query) {

		if (query == null) {
			throw new IllegalArgumentException("Input query can't be null");
		}

		data = query.toCharArray();
		currentIndex = 0;
	}

	/**
	 * Generates and return next token.
	 * 
	 * @return Next token.
	 */
	public Token nextToken() {
		findNextToken();
		return token;
	}

	/**
	 * Get last generated token. It does not start generating the next token.
	 * The method can be run multiple times.
	 * 
	 * @return Last generated token.
	 */
	public Token getToken() {
		return token;
	}

	/**
	 * Searches for the next token in data.
	 * 
	 * @throws LexerException
	 *             Exception thrown if no new tokens are found.
	 */
	private void findNextToken() {

		// If there are no more tokens, throw exception
		if (token != null && token.getType() == TokenType.EOF) {
			throw new LexerException("Current token is EOF; No more tokens left.");
		}

		skipEmptySpaces();

		// If there is no more data left to process generate EOF token
		if (currentIndex >= data.length) {
			token = new Token(TokenType.EOF, null);
			return;
		}

		if (isAttributeName()) {
			return;
		}

		if (isOperator()) {
			return;
		}

		if (isStringLiteral()) {
			return;
		}

		throw new LexerException("Can't find a valid token.");
	}

	/**
	 * Checks if the next token is string literal type. If it is update the
	 * token with the appropriate type and value.
	 * 
	 * @return True if the token is String literal, otherwise false.
	 */
	private boolean isStringLiteral() {

		if (data[currentIndex] == '"') {
			StringBuilder newString = new StringBuilder();
			currentIndex++;
			
			boolean foundStringEnd = false;
			while (currentIndex < data.length) {

				if (data[currentIndex] == '"') {
					foundStringEnd = true;
					break;
				}

				newString.append(data[currentIndex]);
				currentIndex++;
			}

			// If string is left unclosed at the end of the query
			if (!foundStringEnd) {
				return false;
			}
			
			token = new Token(TokenType.STRING_LITERAL, newString.toString());
			currentIndex++;
			return true;
		}

		return false;
	}

	/**
	 * Checks if the next token is operator.If it is update the token with the
	 * appropriate type and value.
	 * 
	 * @return True if the next token is operator, otherwise false.
	 */
	private boolean isOperator() {
		return isLikeOperator() || isLogicalOperator() || isDoubleCharOperator() || isSingleCharOperator();
	}

	/**
	 * Checks if the next token is a logical operator AND. If it is update the
	 * token with the appropriate type and value.
	 * 
	 * @return True if the next token is AND, otherwise false.
	 */
	private boolean isLogicalOperator() {
		
		if (currentIndex+2 < data.length) {
			String checkString = new String(data, currentIndex, 3);

			if (checkString.toLowerCase().equals("and")) {
				token = new Token(TokenType.AND_OPERATOR, checkString);
				currentIndex += 3;
				return true;
			}
		}
		return false;
	}

	/**
	 * Checks if the next token is a two character operator operator. If if it,
	 * update the token with the appropriate type and value.
	 * 
	 * @return True if it is a two character operator, otherwise false.
	 */
	private boolean isSingleCharOperator() {

		if (currentIndex < data.length) {
			String checkString = Character.toString(data[currentIndex]);

			if (checkString.equals("<") || checkString.equals(">") || checkString.equals("=")) {
				token = new Token(TokenType.COMPARISON_OPERATOR, checkString);
				currentIndex += 1;
				return true;
			}
		}

		return false;
	}

	/**
	 * Checks if the next token is a two character operator operator. If if it,
	 * update the token with the appropriate type and value.
	 * 
	 * @return True if it is a two character operator, otherwise false.
	 */
	private boolean isDoubleCharOperator() {

		if (currentIndex + 1 < data.length) {
			String checkString = new String(data, currentIndex, 2);

			if (checkString.equals("<=") || checkString.equals(">=") || checkString.equals("!=")) {
				token = new Token(TokenType.COMPARISON_OPERATOR, checkString);
				currentIndex += 2;
				return true;
			}
		}

		return false;
	}

	/**
	 * Checks if the next token is a like operator. If if it, update the token
	 * with the appropriate type and value.
	 * 
	 * @return True if it is a like operator, otherwise false.
	 */
	private boolean isLikeOperator() {

		if (currentIndex + 3 < data.length) {
			String checkString = new String(data, currentIndex, 4);

			if (checkString.toLowerCase().equals("like")) {
				token = new Token(TokenType.COMPARISON_OPERATOR, checkString);
				currentIndex += 4;
				return true;
			}
		}

		return false;
	}

	/**
	 * Checks if the next token is the attribute token type. If it is update the
	 * token with the appropriate type and value.
	 * 
	 * @return True if the next token is of attribute type, otherwise false.
	 */
	private boolean isAttributeName() {
		return isfirstName() || isLastName() || isJmbag();
	}

	/**
	 * Check if next token is jmbag.
	 * 
	 * @return True if next token is jmbag, otherwise false.
	 */
	private boolean isJmbag() {

		if ((currentIndex + 4) < data.length) {
			String checkString = new String(data, currentIndex, 5);

			if (checkString.equals("jmbag")) {
				token = new Token(TokenType.ATTRIBUTE_NAME, checkString);
				currentIndex += 5;
				return true;
			}
		}

		return false;
	}

	/**
	 * Check if next token is last name. If it is true update the token with the
	 * appropriate type and value.
	 * 
	 * @return True if next token is last name, otherwise false.
	 */
	private boolean isLastName() {

		if ((currentIndex + 7) < data.length) {
			String checkString = new String(data, currentIndex, 8);

			if (checkString.equals("lastName")) {
				token = new Token(TokenType.ATTRIBUTE_NAME, checkString);
				currentIndex += 8;
				return true;
			}
		}

		return false;
	}

	/**
	 * Check if next token is firstName. If it is true update the token with the
	 * appropriate type and value.
	 * 
	 * @return True if next token is first name, otherwise false.
	 */
	private boolean isfirstName() {

		if ((currentIndex + 8) < data.length) {
			String checkString = new String(data, currentIndex, 9);

			if (checkString.equals("firstName")) {
				token = new Token(TokenType.ATTRIBUTE_NAME, checkString);
				currentIndex += 9;
				return true;
			}
		}

		return false;
	}

	/**
	 * Moves curentIndex to the first character in data array that contains a
	 * symbol.
	 */
	private void skipEmptySpaces() {

		while (currentIndex < data.length) {
			char c = data[currentIndex];

			if (isCharBlank(c)) {
				currentIndex++;
				continue;
			}
			break;
		}
	}

	/**
	 * Checks if given character is blank.
	 * 
	 * @param c
	 *            Character the check is performed on.
	 * @return True if the character is blank, otherwise false.
	 */
	private boolean isCharBlank(Character c) {
		if (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
			return true;
		}

		return false;
	}
}
