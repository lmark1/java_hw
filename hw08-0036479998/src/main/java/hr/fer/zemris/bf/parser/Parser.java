package hr.fer.zemris.bf.parser;

import java.util.ArrayList;
import java.util.List;

import hr.fer.zemris.bf.lexer.Lexer;
import hr.fer.zemris.bf.lexer.LexerException;
import hr.fer.zemris.bf.lexer.Token;
import hr.fer.zemris.bf.lexer.TokenType;
import hr.fer.zemris.bf.model.BinaryOperatorNode;
import hr.fer.zemris.bf.model.ConstantNode;
import hr.fer.zemris.bf.model.Node;
import hr.fer.zemris.bf.model.UnaryOperatorNode;
import hr.fer.zemris.bf.model.VariableNode;

/**
 * Parser used for parsing strings containing Boolean algebra. Parser uses
 * several methods implementing grammar rules.
 * 
 * @author Lovro MarkoviÄ‡
 *
 */
public class Parser {

	/**
	 * Lexer used for generating tokens.
	 */
	private Lexer lexer;

	/**
	 * Root of the boolean expression tree.
	 */
	private Node root;

	/**
	 * Last token generated by the lexer.
	 */
	private Token currentToken;

	/**
	 * Initial value is false. Is set to true once EOF tag is found.
	 */
	private boolean endFlag;

	/**
	 * Constructor for Parser object. Accepts input string which will be parsed.
	 * 
	 * @param expression
	 *            Input string.
	 */
	public Parser(String expression) {

		lexer = new Lexer(expression);
		endFlag = false;

		root = generateTree();

		if (currentToken.getTokenType() != TokenType.EOF) {
			throw new ParserException(
					"Unexpected token: " + currentToken.toString());
		}
	}

	/**
	 * Returns a tree node containing expression nodes.
	 * 
	 * @return Node tree.
	 */
	public Node getExpression() {
		return root;
	}

	/**
	 * Generate an expression tree based on the given String expression.
	 * 
	 * @return Returns root of the tree.
	 */
	private Node generateTree() {

		return e1Rule();
	}

	/**
	 * This method implements e1 grammar rule. E1 -> E2 (OR E2)*
	 * 
	 * @return Node generated by that rule.
	 */

	private Node e1Rule() {

		currentToken = getToken();
		Node e2Node = e2Rule();

		if (endFlag) {
			return e2Node;
		}

		List<Node> orList = new ArrayList<>();
		orList.add(e2Node);

		while (currentToken.getTokenType() == TokenType.OPERATOR && currentToken
				.getTokenValue().toString().toLowerCase().equals("or")) {

			currentToken = getToken();
			if (endFlag) {
				throw new ParserException("Unexpected token found: {"
						+ currentToken.toString() + "}.");
			}

			Node orNode = e2Rule();
			orList.add(orNode);
		}

		if (orList.size() == 1) {
			return e2Node;

		} else {
			return new BinaryOperatorNode("or", orList, (t, u) -> t || u);
		}
	}

	/**
	 * This method implements E2 grammar rule. E2 -> E3 (XOR E3)*
	 * 
	 * @return Returns appropriate node, genereted by this rule.
	 */
	private Node e2Rule() {

		Node e3Node = e3Rule();

		if (endFlag) {
			return e3Node;
		}

		List<Node> xorList = new ArrayList<>();
		xorList.add(e3Node);

		while (currentToken.getTokenType() == TokenType.OPERATOR && currentToken
				.getTokenValue().toString().toLowerCase().equals("xor")) {

			currentToken = getToken();
			if (endFlag) {
				throw new ParserException("Unexpected token found: {"
						+ currentToken.toString() + "}.");
			}

			Node xorNode = e3Rule();
			xorList.add(xorNode);
		}

		if (xorList.size() == 1) {
			return e3Node;

		} else {
			return new BinaryOperatorNode("xor", xorList, (t, u) -> t != u);
		}
	}

	/**
	 * This method implements E3 grammar rule. E3 -> E4 (AND E4)*
	 * 
	 * @return Appropriate Node generated by this rule.
	 */
	private Node e3Rule() {

		Node e4Node = e4Rule();

		if (endFlag) {
			return e4Node;
		}

		List<Node> andList = new ArrayList<>();
		andList.add(e4Node);

		while (currentToken.getTokenType() == TokenType.OPERATOR && currentToken
				.getTokenValue().toString().toLowerCase().equals("and")) {

			currentToken = getToken();
			if (endFlag) {
				throw new ParserException("Unexpected token found: {"
						+ currentToken.toString() + "}.");
			}

			Node andNode = e4Rule();
			andList.add(andNode);
		}

		if (andList.size() == 1) {
			return e4Node;

		} else {
			return new BinaryOperatorNode("and", andList, (t, u) -> t && u);
		}
	}

	/**
	 * This method implements E4 grammar rule. E4 -> NOT E4 | E5
	 * 
	 * @return Appropriate node generated by this rule.
	 */
	private Node e4Rule() {
		Node e4Node = null;

		if (currentToken.getTokenType() == TokenType.OPERATOR && currentToken
				.getTokenValue().toString().toLowerCase().equals("not")) {

			currentToken = getToken();
			if (endFlag) {
				throw new ParserException("Unexpected token found: {"
						+ currentToken.toString() + "}.");
			}

			e4Node = new UnaryOperatorNode("not", e4Rule(), u -> !u);

		} else {
			e4Node = e5Rule();
		}

		return e4Node;
	}

	/**
	 * Implement rule 'e5' from the defined parser grammar. E5 -> VAR | KONST |
	 * '(' E1 ')'
	 * 
	 * @return Node that satisfies this ruleset.
	 */
	private Node e5Rule() {
		Node e5Node = null;

		if (currentToken.getTokenType() == TokenType.VARIABLE) {
			e5Node = new VariableNode(currentToken.getTokenValue().toString());
		}

		else if (currentToken.getTokenType() == TokenType.CONSTANT) {
			e5Node = new ConstantNode((boolean) currentToken.getTokenValue());
		}

		else if (currentToken.getTokenType() == TokenType.OPEN_BRACKET) {

			// get Bracket contents
			e5Node = e1Rule();

			if (!(currentToken.getTokenType() == TokenType.CLOSED_BRACKET)) {
				throw new ParserException("Expected ')' but found "
						+ currentToken.getTokenType() + ".");
			}
		}

		else {
			throw new ParserException(
					"Unexpected token found: " + currentToken.toString());
		}

		if (endFlag) {
			return e5Node;

		} else {
			currentToken = getToken();
			return e5Node;
		}
	}

	/**
	 * Safe method for getting tokens. Also sets end flag if EOF token appears.
	 * 
	 * @return Next token.
	 */
	private Token getToken() {
		Token newToken = null;

		try {
			newToken = lexer.nextToken();

		} catch (LexerException e) {
			throw new ParserException(
					"Lexer has thrown exception: " + e.getMessage());
		}

		if (newToken.getTokenType() == TokenType.EOF) {
			endFlag = true;
		}
		return newToken;
	}
}
