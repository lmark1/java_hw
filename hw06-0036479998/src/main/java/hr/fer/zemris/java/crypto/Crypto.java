package hr.fer.zemris.java.crypto;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.spec.AlgorithmParameterSpec;
import java.util.Scanner;

import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

/**
 * This class is used for checking digest, encrypting and decrypting files. The
 * first command line argument has to be a command: checksha, encrypt or
 * decrypt. Other arguments can be either a single file if using checksha
 * command or two files if using encrpyt / decrypt commands.
 * 
 * @author Lovro Marković
 *
 */
public class Crypto {

	/**
	 * Size of a buffer used when encrypting / decrypting.
	 */
	private static int BUFFER_SIZE = 4096;

	/**
	 * Main method of the program. Executes when program is run.
	 * 
	 * @param args
	 *            Expects 2 or 3 arguments depending on the first one given.
	 *            First argument has to be a command: checksha, encrypt of
	 *            decrpyt. Other arguments can be either a single file if using
	 *            checksha command or two files if using encrpyt / decrypt
	 *            commands.
	 */
	public static void main(String[] args) {

		if (args.length != 2 && args.length != 3) {
			System.out.println("Program expects either 2 or 3 arguments.");
			return;
		}

		if (args[0].toLowerCase().equals("checksha") && args.length == 2) {
			processCheckshaCommand(args[1]);
			return;
		}

		if (args[0].toLowerCase().equals("encrypt") && args.length == 3) {
			processEncryptCommand(args[1], args[2]);
			return;
		}

		if (args[0].toLowerCase().equals("decrypt") && args.length == 3) {
			processDecryptCommand(args[1], args[2]);
			return;
		}

		System.out.println(
				"Unrecognized command given. Avaliable commands: checksha, encrypt, decrypt.");
	}

	/**
	 * Prompts the user for password and initialization vecotr. Decrpyts the
	 * given encryptedFile using the AES cryptography algorithm. Saves the
	 * decrypted file.
	 * 
	 * @param encryptedPath
	 *            Input file that is encrypted.
	 * @param outputPath
	 *            Decrypted output file.
	 */
	private static void processDecryptCommand(String encryptedPath,
			String outputPath) {
		
		CryptoData userInput = getEncryptionData();
		Cipher cipher = initializeCipher(userInput, false);

		if (cipher == null) {
			System.out.println(
					"Exception happened during cipher initialization.");
			System.exit(1);
		}
		
		encryptOrDecryptFile(encryptedPath, outputPath, cipher);

		System.out.format(
				"Decryption completed. Generated file %s based on file %s%n",
				outputPath, encryptedPath);
	}

	/**
	 * Prompts the user for password and initialization vector. Encrypts the
	 * given file using the AES cryptography algorithm. Saves the encrypted
	 * file.
	 * 
	 * @param inputPath
	 *            Path to the file that will be encrypted.
	 * @param encryptedPath
	 *            Path to the encrypted file.
	 */
	private static void processEncryptCommand(String inputPath,
			String encryptedPath) {

		CryptoData userInput = getEncryptionData();
		Cipher cipher = initializeCipher(userInput, true);

		if (cipher == null) {
			System.out.println(
					"Exception happened during cipher initialization.");
			System.exit(1);
		}

		encryptOrDecryptFile(inputPath, encryptedPath, cipher);

		System.out.format(
				"Encryption completed. Generated file %s based on file %s%n",
				inputPath, encryptedPath);
	}

	/**
	 * Encrypt or decrypt, depending on the given cipher, generated by the input
	 * stream and write it to the output stream.
	 * 
	 * @param inputPath
	 *            Path of the source data.
	 * @param outputPath
	 *            Destination path.
	 * @param cipher
	 *            Cipher used for encryption / decription.
	 */
	private static void encryptOrDecryptFile(String inputPath,
			String outputPath, Cipher cipher) {
		
		BufferedInputStream inputStream = null;
		BufferedOutputStream outputStream = null;
		
		try {
			Path inputFile = Paths.get("./" + inputPath);
			Path outputFile = Paths.get("./" + outputPath);

			inputStream = new BufferedInputStream(
					new FileInputStream(inputFile.toFile()));
			outputStream = new BufferedOutputStream(
					new FileOutputStream(outputFile.toFile()));

		} catch (IOException e) {
			e.printStackTrace();
			return;
		}

		byte[] inputBuffer = new byte[BUFFER_SIZE];
		try {
			int currentSize = inputStream.read(inputBuffer);
			
			while (currentSize >= 0) {
				byte[] outputUpdate = cipher.update(inputBuffer, 0, currentSize);
				outputStream.write(outputUpdate);
				currentSize = inputStream.read(inputBuffer);
			}
			
			byte[] outputFinalUpdate = cipher.doFinal();
			outputStream.write(outputFinalUpdate);

		} catch (IOException e) {
			e.printStackTrace();
			System.exit(1);

		} catch (IllegalBlockSizeException e) {
			e.printStackTrace();
			System.exit(1);

		} catch (BadPaddingException e) {
			e.printStackTrace();
			System.exit(1);

		}
		
		try {
			inputStream.close();
			outputStream.close();
			
		} catch (IOException e) {
			e.printStackTrace();
			System.exit(1);
		}
	}

	/**
	 * Initializes cipher object according to the password and initialization
	 * vector stored in given CryptoData object. Encryption / decryption
	 * algorithm is AES.
	 * 
	 * @param userInput
	 *            Given userInput containing password and initialization vector.
	 * @param cypherState
	 *            True if the cypher will encrypt files or false if it will
	 *            decrypt files.
	 * @return Initialized cipher object or null if there was an exception
	 *         during the initialization.
	 */
	private static Cipher initializeCipher(CryptoData userInput,
			boolean cypherState) {

		Cipher cipher = null;
		try {
			SecretKeySpec keySpec = new SecretKeySpec(
					Util.hexToByte(userInput.password), "AES");
			AlgorithmParameterSpec paramSpec = new IvParameterSpec(
					Util.hexToByte(userInput.initVector));

			cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");

			boolean encrypt = cypherState;
			cipher.init(encrypt ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE,
					keySpec, paramSpec);

		} catch (NoSuchAlgorithmException e1) {
			System.out.println(e1.getMessage());
			return null;

		} catch (NoSuchPaddingException e1) {
			System.out.println(e1.getMessage());
			return null;

		} catch (IllegalArgumentException e1) {
			System.out.println(e1.getMessage());
			return null;

		} catch (InvalidKeyException e) {
			System.out.println(e.getMessage());
			return null;

		} catch (InvalidAlgorithmParameterException e) {
			System.out.println(e.getMessage());
			return null;
		}

		return cipher;
	}

	/**
	 * Prompts the user for password and initialization vector.
	 * 
	 * @return CryptoData object conatining password and initialization vector.
	 */
	private static CryptoData getEncryptionData() {
		CryptoData newData = new CryptoData();
		Scanner scanner = new Scanner(System.in);

		System.out.println(
				"Please provide password as hex-encoded text (16 bytes, i.e. 32 hex-digits):");
		newData.password = getUserInput(scanner);

		System.out.println(
				"Please provide initialization vector as hex-encoded text (32 hex-digits):");
		newData.initVector = getUserInput(scanner);

		scanner.close();
		return newData;
	}

	/**
	 * Prompts the user for the digest of the given file. Calculates the digest
	 * of the file defined by the second argument and checks if it is the same
	 * as the prompted one.
	 * 
	 * @param binName
	 *            Name of a file which digest will be calculated.
	 */
	private static void processCheckshaCommand(String binName) {

		String digest = null;
		try {
			Path binFile = Paths.get("./" + binName);
			BufferedInputStream os = new BufferedInputStream(
					new FileInputStream(binFile.toFile()));
			digest = generateDigest(os);

		} catch (IOException e) {
			System.out.println(e.getMessage());
			return;
		}

		System.out.format("Please provide expected sha-256 digest for %s:%n",
				binName);

		Scanner scanner = new Scanner(System.in);
		String userInput = getUserInput(scanner);
		scanner.close();

		if (userInput.equals(digest)) {
			System.out.format(
					"Digesting completed. Digest of %s matches expected digest.%n",
					binName);

		} else {
			System.out.format(
					"Digesting completed. Digest of %s does not match expected digest.%nDigest was: %s%n",
					binName, digest);
		}
	}

	/**
	 * Returns a String user inputted.
	 * 
	 * @param inputScan
	 *            Scanner used for getting user input.
	 * 
	 * @return User input.
	 */
	private static String getUserInput(Scanner inputScan) {
		System.out.print(">");
		String userInput = inputScan.nextLine();
		return userInput;
	}

	/**
	 * Generates digest based on the content found in the given data stream.
	 * 
	 * @param os
	 *            Given buffered stream.
	 * @return String representing digest.
	 */
	private static String generateDigest(BufferedInputStream os) {

		// Initialize MessageDigest object
		MessageDigest newDigest = null;
		try {
			newDigest = MessageDigest.getInstance("SHA-256");

		} catch (NoSuchAlgorithmException e) {
			System.out.println(e.getMessage());
			System.exit(1);
		}

		// Feed bytes into MessageDigest object
		while (true) {
			int singleByte = 0;

			try {
				singleByte = os.read();
				if (singleByte < 0)
					break;

			} catch (IOException e) {
				System.out.println("Error while reading from buffer");
				System.err.println(e.getMessage());
				System.exit(1);
			}

			newDigest.update((byte) singleByte);
		}

		return Util.byteToHex(newDigest.digest());
	}

	/**
	 * Static class used for storing user input for encryption / decrpytion.
	 * Stores initialization vector and password.
	 * 
	 * @author Lovro Marković
	 *
	 */
	private static class CryptoData {

		/**
		 * Initialization vector as a hex-coded text.
		 */
		private String initVector;

		/**
		 * Password as a hex-coded text.
		 */
		private String password;
	}
}
