package hr.fer.zemris.bf.utils;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;

import hr.fer.zemris.bf.model.BinaryOperatorNode;
import hr.fer.zemris.bf.model.ConstantNode;
import hr.fer.zemris.bf.model.Node;
import hr.fer.zemris.bf.model.NodeVisitor;
import hr.fer.zemris.bf.model.UnaryOperatorNode;
import hr.fer.zemris.bf.model.VariableNode;

/**
 * This class implements NodeVisitor interface. It is used for evaluating
 * boolearn expression generated by the pareser.
 * 
 * @author Lovro MarkoviÄ‡
 *
 */
public class ExpressionEvaluator implements NodeVisitor {

	/**
	 * Variables in the expression.
	 */
	@SuppressWarnings("unused")
	private List<String> variables;

	/**
	 * Array of current variable values.
	 */
	private boolean[] values;

	/**
	 * Maps names of variables as keys and their indexes as values.
	 */
	private Map<String, Integer> positions;

	/**
	 * Stack used for storing boolean values.
	 */
	private Stack<Boolean> stack;

	/**
	 * Constructor for the ExpressionEvaluator class. Accepts list of variables
	 * present in the expression.
	 * 
	 * @param variables
	 *            List of variables type String.
	 */
	public ExpressionEvaluator(List<String> variables) {
		this.variables = variables;
		values = new boolean[variables.size()];
		stack = new Stack<>();
		positions = new HashMap<>(); 
				
		for (int i = 0; i < variables.size(); i++) {
			positions.put(variables.get(i), i);
		}
	}

	/**
	 * Setter for the array of boolean values.
	 * 
	 * @param values
	 *            New boolean array.
	 * @throws IllegalArgumentException
	 *             Exception thrown if length of given array does not equal to
	 *             initialized length of array.
	 */
	public void setValues(boolean[] values) {
		start();
		
		if (values.length != this.values.length) {
			throw new IllegalArgumentException(
					"Given boolean array should be length: "
							+ this.values.length);
		}

		for (int i = 0; i < this.values.length; i++) {
			this.values[i] = values[i];
		}
	}

	@Override
	public void visit(ConstantNode node) {
		stack.push(node.getValue());
	}

	/**
	 * {@inheritDoc}
	 * 
	 * @throws IllegalStateException
	 *             Exception thrown if map does not contain found variable.
	 */
	@Override
	public void visit(VariableNode node) {

		if (!positions.containsKey(node.getValue())) {
			throw new IllegalStateException(
					"Map does not contain variable: " + node.getValue());
		}

		stack.push(values[positions.get(node.getValue())]);
	}

	@Override
	public void visit(UnaryOperatorNode node) {
		node.getChild().accept(this);
		
		Boolean childValue = stack.pop();
		stack.push(node.getOperator().apply(childValue));
	}

	@Override
	public void visit(BinaryOperatorNode node) {
		List<Node> children = node.getChildren();
		int numberOfChildren = 0;
		
		for (Node child : children) {
			child.accept(this);
			numberOfChildren++;
		}
		
		Boolean result = node.getOperator().apply(stack.pop(), stack.pop());
		for (int i = 0; i < numberOfChildren - 2; i++) {
			result = node.getOperator().apply(result, stack.pop());
		}
		
		stack.push(result);
	}
	
	/**
	 * Returns result of the expression.
	 * 
	 * @return Result of the expression.
	 */
	public boolean getResult() {
		
		if (stack.size() != 1) {
			throw new IllegalStateException("Number of elements on stack ");
		}		
		
		return stack.peek();
	}
	
	/**
	 * Erases stack contents.
	 */
	private void start() {
		stack.removeAllElements();
	}
}
